// Client-side ORB WebAR (OpenCV.js + Three.js)
// Loads target/target.json (precompiled ORB descriptors)
// Runs ORB on camera frames, matches, computes homography via RANSAC
let videoEl=null, stream=null, cvReady=false, targetData=null;
let cvCanvas, ctx, camGray=null, camMatRGBA=null, detector=null, matcher=null, targetDescriptorsMat=null;
let tplWidth=0, tplHeight=0, isRunning=false;
const startBtn=document.getElementById('startBtn'), scanOverlay=document.getElementById('scanOverlay');
let renderer, scene, camera3, planeMesh;
function initThree(){ const container=document.getElementById('threeContainer'); renderer=new THREE.WebGLRenderer({alpha:true,antialias:true}); renderer.setSize(window.innerWidth,window.innerHeight); container.appendChild(renderer.domElement); scene=new THREE.Scene(); camera3=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.01,1000); camera3.position.set(0,0,2); const geom=new THREE.PlaneGeometry(1,1); const videoTex=new THREE.VideoTexture(document.getElementById('overlayVideo')); const mat=new THREE.MeshBasicMaterial({map:videoTex,transparent:true}); planeMesh=new THREE.Mesh(geom,mat); planeMesh.visible=false; scene.add(planeMesh); (function render(){ renderer.render(scene,camera3); requestAnimationFrame(render); })(); }
function onOpenCvReady(){ console.log('OpenCV.js ready'); cvReady=true; }
function loadTarget(){ return fetch('./target/target.json').then(r=>r.json()).then(j=>{ targetData=j; tplWidth=j.width; tplHeight=j.height; return j; }); }
async function startCamera(){ videoEl=document.createElement('video'); videoEl.setAttribute('playsinline',''); videoEl.muted=true; videoEl.autoplay=true; videoEl.style.display='none'; document.body.appendChild(videoEl); stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'},audio:false}); videoEl.srcObject=stream; await new Promise(r=> videoEl.onloadedmetadata=r); videoEl.play(); }
function prepareOpenCVObjects(){ const w=videoEl.videoWidth, h=videoEl.videoHeight; cvCanvas=document.getElementById('cvcanvas'); cvCanvas.width=w; cvCanvas.height=h; ctx=cvCanvas.getContext('2d'); camGray=new cv.Mat(h,w,cv.CV_8UC1); camMatRGBA=new cv.Mat(h,w,cv.CV_8UC4); detector=new cv.ORB(); matcher=new cv.BFMatcher(); if (targetData && targetData.descriptors && targetData.descriptors.length>0){ targetDescriptorsMat = cv.matFromArray(targetData.descriptors.length, targetData.descriptors[0].length, cv.CV_8U, targetData.descriptors.flat()); } }
function matchAndEstimate(){ if (!cvReady || !videoEl || !isRunning) return; ctx.drawImage(videoEl,0,0,cvCanvas.width,cvCanvas.height); let imageData=ctx.getImageData(0,0,cvCanvas.width,cvCanvas.height); camMatRGBA.data.set(imageData.data); cv.cvtColor(camMatRGBA, camGray, cv.COLOR_RGBA2GRAY); let kps=new cv.KeyPointVector(); let desc=new cv.Mat(); detector.detectAndCompute(camGray, new cv.Mat(), kps, desc); if (desc.empty() || !targetDescriptorsMat){ kps.delete(); desc.delete(); requestAnimationFrame(matchAndEstimate); return; } let matches=new cv.DMatchVector(); matcher.match(desc, targetDescriptorsMat, matches); let mlist=[]; for (let i=0;i<matches.size();i++){ const mm=matches.get(i); mlist.push({queryIdx:mm.queryIdx, trainIdx:mm.trainIdx, distance:mm.distance}); } mlist.sort((a,b)=>a.distance-b.distance); const good=mlist.slice(0, Math.min(60, mlist.length)); if (good.length < 8){ planeMesh.visible=false; document.getElementById('overlayVideo').pause(); requestAnimationFrame(matchAndEstimate); kps.delete(); desc.delete(); matches.delete(); return; } const srcPts=[]; const dstPts=[]; for (let gm of good){ const qkp=kps.get(gm.queryIdx); const tpt=targetData.keypoints[gm.trainIdx].pt; srcPts.push(qkp.pt.x, qkp.pt.y); dstPts.push(tpt[0], tpt[1]); } const srcMat = cv.matFromArray(good.length,1,cv.CV_32FC2, srcPts); const dstMat = cv.matFromArray(good.length,1,cv.CV_32FC2, dstPts); let mask=new cv.Mat(); try{ const H = cv.findHomography(dstMat, srcMat, cv.RANSAC, 5, mask); if (!H.empty()){ const corners = cv.matFromArray(4,1,cv.CV_32FC2, [0,0, tplWidth,0, tplWidth,tplHeight, 0,tplHeight]); const dstCorners = new cv.Mat(); cv.perspectiveTransform(corners, dstCorners, H); const arr = dstCorners.data32F; const x0=arr[0], y0=arr[1], x1=arr[2], y1=arr[3], x2=arr[4], y2=arr[5], x3=arr[6], y3=arr[7]; const cx=(x0+x1+x2+x3)/4, cy=(y0+y1+y2+y3)/4; const wcam=Math.hypot(x1-x0, y1-y0); const hcam=Math.hypot(x3-x0, y3-y0); const vw=cvCanvas.width, vh=cvCanvas.height; const nx=(cx/vw - 0.5)*(vw/vh)*2.0; const ny=(0.5 - cy/vh)*2.0; const scale = wcam / tplWidth * 2.0; planeMesh.position.set(nx, ny, 0); planeMesh.scale.set(scale*(vw/vh), scale*(tplHeight/tplWidth), 1); planeMesh.visible=true; document.getElementById('overlayVideo').play(); } else { planeMesh.visible=false; document.getElementById('overlayVideo').pause(); } H.delete(); corners.delete(); dstCorners.delete(); } catch(e){ console.log('homography error', e); planeMesh.visible=false; document.getElementById('overlayVideo').pause(); } srcMat.delete(); dstMat.delete(); mask.delete(); kps.delete(); desc.delete(); matches.delete(); requestAnimationFrame(matchAndEstimate); }
async function startAR(){ await loadTarget(); await startCamera(); prepareOpenCVObjects(); initThree(); isRunning=true; matchAndEstimate(); }
startBtn.onclick = async ()=>{ startBtn.style.display='none'; scanOverlay.style.display='flex'; if (!window.cv || !cv.ORB){ const waitFor = ()=> new Promise(res => { const intr = setInterval(()=>{ if (window.cv && window.cv.ORB){ clearInterval(intr); res(); } }, 200); }); await waitFor(); } onOpenCvReady(); startAR(); };
