<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>WebAR MVP â€” Template Match + Video</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    html,body { margin: 0; height: 100%; overflow: hidden; background: #000; }
    #startBtn { position: absolute; z-index: 20; inset:0; display:flex; align-items:center; justify-content:center; font-size:24px; color:#fff; background:#000; cursor:pointer; }
    #scanOverlay { position: absolute; z-index: 18; inset:0; display:none; align-items:center; justify-content:center; color:#fff; font-size:20px; pointer-events:none; }
    #canvasOutput { position: absolute; z-index: 1; top:0; left:0; width:100%; height:100%; object-fit:cover; }
    #threeContainer { position:absolute; inset:0; z-index:5; pointer-events:none; }
  </style>
</head>
<body>
  <div id="startBtn">Tap to Start AR</div>
  <div id="scanOverlay">Point your camera at the card</div>

  <!-- Video element (hidden) -->
  <video id="overlayVideo" src="./assets/video.mp4" loop muted playsinline style="display:none"></video>

  <!-- OpenCV.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="console.log('OpenCV.js loaded')"></script>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

  <div id="threeContainer"></div>
  <canvas id="canvasOutput"></canvas>

<script>
let videoEl=null, isRunning=false;
let tmplMat=null, tmplGray=null, grayMat=null;
let canvasOut, ctxOut;

const startBtn = document.getElementById('startBtn');
const scanOverlay = document.getElementById('scanOverlay');

async function startCamera() {
  videoEl = document.createElement('video');
  videoEl.setAttribute('playsinline','');
  videoEl.muted = true; videoEl.autoplay = true; videoEl.style.display='none';
  document.body.appendChild(videoEl);
  const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false });
  videoEl.srcObject = stream;
  return new Promise(resolve => { videoEl.onloadedmetadata = ()=>{ videoEl.play(); resolve(); }; });
}

let renderer, scene, camera3, planeMesh;
function initThree() {
  const container = document.getElementById('threeContainer');
  const width = container.clientWidth || window.innerWidth;
  const height = container.clientHeight || window.innerHeight;
  renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
  renderer.setSize(width, height); renderer.setPixelRatio(window.devicePixelRatio||1);
  container.appendChild(renderer.domElement);
  scene = new THREE.Scene();
  camera3 = new THREE.PerspectiveCamera(60, width/height, 0.01, 1000);
  camera3.position.set(0,0,2);
  const geom = new THREE.PlaneGeometry(1,1);
  const videoTexture = new THREE.VideoTexture(document.getElementById('overlayVideo'));
  const mat = new THREE.MeshBasicMaterial({ map: videoTexture, transparent:true, side:THREE.DoubleSide });
  planeMesh = new THREE.Mesh(geom, mat); planeMesh.visible=false; scene.add(planeMesh);
}

function updatePlaneFromRect(rect, frameW, frameH) {
  const vw = window.innerWidth, vh = window.innerHeight;
  const cx = (rect.x + rect.w/2) / frameW - 0.5;
  const cy = 0.5 - (rect.y + rect.h/2) / frameH;
  const aspect = rect.w / rect.h;
  const scale = rect.w / frameW * 2.0;
  planeMesh.position.set(cx * (vw/vh) * 1.2, cy * 1.2, 0);
  planeMesh.scale.set(scale * (vw/vh), scale / aspect, 1);
  planeMesh.visible = true;
}

async function runLoop() {
  const FPS = 12;
  const frameW = grayMat.cols, frameH = grayMat.rows;
  const scales = [1.0,0.9,0.8,0.7,0.6];
  let best = {maxVal:-1, rect:null};
  for (let s of scales) {
    const newW = Math.round(tmplGray.cols * s);
    const newH = Math.round(tmplGray.rows * s);
    if (newW < 20 || newH < 20 || newW > frameW || newH > frameH) continue;
    let resized = new cv.Mat();
    cv.resize(tmplGray, resized, new cv.Size(newW,newH), 0,0, cv.INTER_AREA);
    const resultCols = frameW - newW + 1;
    const resultRows = frameH - newH + 1;
    if (resultCols <= 0 || resultRows <= 0) { resized.delete(); continue; }
    let result = new cv.Mat();
    cv.matchTemplate(grayMat, resized, result, cv.TM_CCOEFF_NORMED);
    const mm = cv.minMaxLoc(result);
    if (mm.maxVal > best.maxVal) {
      best.maxVal = mm.maxVal;
      best.rect = { x: mm.maxLoc.x, y: mm.maxLoc.y, w: newW, h: newH, scale: s };
    }
    result.delete(); resized.delete();
  }
  // draw preview
  ctxOut.drawImage(videoEl, 0,0, canvasOut.width, canvasOut.height);
  if (best.maxVal > 0.55) {
    ctxOut.strokeStyle='lime'; ctxOut.lineWidth=4;
    const sx = canvasOut.width / frameW; const sy = canvasOut.height / frameH;
    ctxOut.strokeRect(best.rect.x * sx, best.rect.y * sy, best.rect.w * sx, best.rect.h * sy);
    updatePlaneFromRect(best.rect, frameW, frameH);
    scanOverlay.style.display='none';
    document.getElementById('overlayVideo').play();
  } else {
    planeMesh.visible=false;
    scanOverlay.style.display='flex';
    document.getElementById('overlayVideo').pause();
  }
  if (isRunning) setTimeout(()=>requestAnimationFrame(runLoop), 1000/FPS);
}

async function startAR() {
  await startCamera();
  canvasOut = document.getElementById('canvasOutput');
  canvasOut.width = window.innerWidth; canvasOut.height = window.innerHeight;
  ctxOut = canvasOut.getContext('2d');
  // prepare mats
  const w = videoEl.videoWidth, h = videoEl.videoHeight;
  grayMat = new cv.Mat(h, w, cv.CV_8UC1);
  // load template
  const img = new Image(); img.src = './assets/target.jpg';
  await new Promise(r=> img.onload = r);
  const tmpCanvas = document.createElement('canvas'); tmpCanvas.width=img.width; tmpCanvas.height=img.height;
  tmpCanvas.getContext('2d').drawImage(img,0,0);
  const id = tmpCanvas.getContext('2d').getImageData(0,0,img.width,img.height);
  tmplMat = cv.matFromImageData(id);
  tmplGray = new cv.Mat(); cv.cvtColor(tmplMat, tmplGray, cv.COLOR_RGBA2GRAY);
  initThree();
  // capture frames
  const processCameraFrame = () => {
    if (!videoEl || videoEl.readyState < 2) { requestAnimationFrame(processCameraFrame); return; }
    const w = videoEl.videoWidth, h = videoEl.videoHeight;
    const capMat = new cv.Mat(h, w, cv.CV_8UC4);
    const tmp = document.createElement('canvas'); tmp.width=w; tmp.height=h;
    tmp.getContext('2d').drawImage(videoEl,0,0,w,h);
    const idata = tmp.getContext('2d').getImageData(0,0,w,h);
    capMat.data.set(idata.data);
    cv.cvtColor(capMat, grayMat, cv.COLOR_RGBA2GRAY);
    capMat.delete();
    if (isRunning) requestAnimationFrame(processCameraFrame);
  };
  isRunning=true; processCameraFrame(); runLoop();
  (function renderThree(){ if (renderer) renderer.render(scene, camera3); requestAnimationFrame(renderThree); })();
}

startBtn.onclick = async ()=> { startBtn.style.display='none'; scanOverlay.style.display='flex'; await startAR(); };
</script>
</body>
</html>
